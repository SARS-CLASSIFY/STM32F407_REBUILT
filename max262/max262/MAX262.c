//-----------------------------------------------------------------
// 程序描述: 
//		MAX262驱动代码
// 作    者: 凌智电子
// 开始日期: 2018-05-24
// 完成日期: 2018-05-24
// 修改日期:
// 版    本: V1.0
//   - V1.0: 初步模板
// 调试工具: 凌智STM32+FPGA电子系统设计开发板、LZE_ST LINK2、MAX262模块
// 说    明:
//-----------------------------------------------------------------

//-----------------------------------------------------------------
// 头文件包含
//-----------------------------------------------------------------
#include <stm32f10x.h>
#include "MAX262.h"
#include "delay.h"
#include <math.h>

extern int Fn;
//-----------------------------------------------------------------
// 功能程序区
//-----------------------------------------------------------------


//-----------------------------------------------------------------
// u8 Qn(float q)                     
//-----------------------------------------------------------------
// 函数功能: 计算Q的控制字N
// 入口参数: Q
// 返 回 值: 控制字N
// 全局变量: 无
// 注意事项: 无
//-----------------------------------------------------------------
u8 Qn(float q)                     //品质因数关键字
{
    u8 temp;
    temp = 128-(64/q);             //具体看芯片手册上有公式
    return temp; 
}

//-----------------------------------------------------------------
// void Filter1(uint8_t mode, float f, float q)
//-----------------------------------------------------------------
// 函数功能: 滤波器2的模式、频率以及Q值的设置
// 入口参数: 模式 mode, 截止/中心 频率 f, Q值 q
// 返 回 值: 无
// 全局变量: 无
// 注意事项: 无
//-----------------------------------------------------------------
void Filter1(u8 mode, float q)
{
	uint8_t i;
	uint8_t a = 0x03;
	uint8_t  sq;
	i = sq = 0;
// 	sf = Fn(f);                     // 求出其频率控制字N
	sq = Qn(q);                     // 求出Q对应的控制字N
	LE_H;                           // 使能端拉高
	Delay_ns(200);
	WR_H;                           // 写端口拉高
	Delay_ns(200);
	
	// 具体可见芯片手册 P15 Table4	
	
	GPIOB->BRR = 0x3f00;	          // 写入模式的地址
	Delay_ns(200);
	WR_L;                           //写端口拉低
	Delay_ns(200);
// 	GPIOB->BRR = 0x0300;
	GPIOB->ODR |= ((uint16_t)(mode & 0x03) << 8);    // 将模式控制字送给D1, D0
	Delay_ns(200);
	WR_H;                           // 写端口拉高
	Delay_ns(200);
	
	for(i = 0; i < 3; i++)
	{
		GPIOB -> BRR = 0x3f00;	          // 现将地址与数据位清0
		GPIOB -> ODR |= (uint16_t)(i+1)<<10;          // 写入地址
		Delay_ns(200);
		WR_L;                             // 写入拉低
		Delay_ns(200);
// 		GPIOB->BRR = 0x0300;            //数据位清0
		GPIOB->ODR |= ((uint16_t)(Fn & a) << (8-2*i));		  // 将f的控制字N写入
		Delay_ns(200);
		WR_H;                             // 写入拉高
		a = a << 2;                       // a左移2位		
	}
	
	a = 0x03;
	
	for(i = 0; i < 4; i++)
	{
		GPIOB -> BRR = 0x3f00;	          // 现将地址与数据位清0
		GPIOB -> ODR |= (uint16_t)(i+4)<<10;          // 写入地址
		Delay_ns(200);
		WR_L;                             // 写入拉低
		Delay_ns(200);
// 		GPIOB->BRR = 0x0300;              //数据位清0
		GPIOB->ODR |= ((uint16_t)(sq & a) << (8-2*i));		  // 将Q的控制字N写入
		Delay_ns(200);                   
		WR_H;                             // 写入拉高
		a = a << 2;                       // a左移2位		
	}
}

//-----------------------------------------------------------------
// void Filter2(uint8_t mode, float f, float q)
//-----------------------------------------------------------------
// 函数功能: 滤波器2的模式、频率以及Q值的设置
// 入口参数: 模式 mode, 截止/中心 频率 f, Q值 q
// 返 回 值: 无
// 全局变量: 无
// 注意事项: 无
//-----------------------------------------------------------------
void Filter2(u8 mode, float q)
{
	uint8_t i;
	uint8_t a = 0x03;
	uint8_t sq;
	i = sq = 0;
// 	sf = Fn(f);                     // 求出其频率控制字N
	sq = Qn(q);                     // 求出Q对应的控制字N
	LE_H;                           // 使能端拉高
	Delay_ns(200);
	WR_H;                           // 写端口拉高
	Delay_ns(200);
	
	GPIOB->BRR = 0x3f00;	          // 写入模式的地址
	GPIOB -> ODR |= (uint16_t)(i+8)<<10;          // 写入地址
	Delay_ns(200);
	WR_L;                           // 写端口拉低
	Delay_ns(200);
// 	GPIOB->BRR = 0x0300;
	GPIOB->ODR |= ((uint16_t)(mode & 0x03) << 8);    //将模式控制字送给D1, D0
	Delay_ns(200);
	WR_H;                           // 写端口拉高
	Delay_ns(200);
	
	for(i = 0; i < 3; i++)
	{
		GPIOB -> BRR = 0x3f00;	          // 现将地址与数据位清0
		GPIOB -> ODR |= (uint16_t)(i+9)<<10;          // 写入地址
		Delay_ns(200);
		WR_L;                             // 写入拉低
		Delay_ns(200);
// 		GPIOB->BRR = 0x0300;            //数据位清0
		GPIOB->ODR |= ((uint16_t)(Fn & a) << (8-2*i));		  // 将f的控制字N写入
		Delay_ns(200);                   
		WR_H;                             // 写入拉高
		a = a << 2;                       // a左移2位		
	}
	
	a = 0x03;
	
	for(i = 0; i < 4; i++)
	{
		GPIOB -> BRR = 0x3f00;	          // 现将地址与数据位清0
		GPIOB -> ODR |= (uint16_t)(i+12)<<10;          // 写入地址
		Delay_ns(200);
		WR_L;                             // 写入拉低
		Delay_ns(200);
		GPIOB->ODR |= ((uint16_t)(sq & a) << (8-2*i));		  // 将Q的控制字N写入
		Delay_ns(200);                   
		WR_H;                             // 写入拉高
		a = a << 2;                       // a左移2位		
	}
}

//-----------------------------------------------------------------
// End Of File
//-----------------------------------------------------------------
